#pragma warning(disable : 4275)
#pragma warning(disable : 4996)
#include "wxf_base.h"

#ifdef WIN32

#define wxf_get_entry_name				wxf_getname
#define wxf_entryisdir					wxf_isdir
#define wxf_app_free					wxf_free
#define wxf_app_malloc					wxf_malloc

#define WXF_ASSERT						wxf_assert

/********************************************************************************************* 
** Function name  : win_opendir
** Arguments      : dirname - 
** Return         : wxf_dir_t 
** Date&Time      : 2012-09-05  10:05:14
** Description    : 
*********************************************************************************************/ 
wxf_dir_t win_opendir(const char* dirname)
{
	wxf_dir_t ret;

	if(_chdir(dirname))
	{
		printf("Unable to locate the directory: %s\n", dirname);
		return NULL;
	}
	else 
	{
		ret = (wxf_dir_t)malloc(sizeof(wxf_dir));
		/* Find first in the current directory */
		ret->dir =  _findfirst("*.*", &(ret->dirent)); 
		return ret;
	}
}

/********************************************************************************************* 
** Function name  : win_closedir
** Arguments      : dir - 
** Return         : int 
** Date&Time      : 2012-09-05  10:05:17
** Description    : 
*********************************************************************************************/ 
int win_closedir(wxf_dir_t dir)
{
	_findclose(dir->dir); 
	free(dir);
	return 0;
}

/********************************************************************************************* 
** Function name  : win_readdir
** Arguments      : dir - 
** Return         : wxf_dirent_t 
** Date&Time      : 2012-09-05  10:05:18
** Description    : 
*********************************************************************************************/ 
wxf_dirent_t win_readdir(wxf_dir_t dir)
{	
	if (_findnext(dir->dir, &(dir->dirent)) == 0)
		return &(dir->dirent);
	else
		return NULL;
}

/********************************************************************************************* 
** Function name  : win_entry_is_dir
** Arguments      : dirent - 
** Return         : int 
** Date&Time      : 2012-09-05  10:05:20
** Description    : 
*********************************************************************************************/ 
int win_entry_is_dir(wxf_dirent_t dirent)
{
	struct _finddata_t* entry = (struct _finddata_t*)dirent;

	if (entry->attrib & _A_SUBDIR)
		return true;
	else
		return false;
}

/********************************************************************************************* 
** Function name  : win_get_entry_name
** Arguments      : dirent - 
** Return         : char* 
** Date&Time      : 2012-09-05  10:05:21
** Description    : 
*********************************************************************************************/ 
char* win_get_entry_name(void *dirent)
{
#ifdef _WIN32
	struct _finddata_t* entry = (struct _finddata_t*)dirent;
	return entry->name;
#else
	return dirent->d_name;
#endif
}

/********************************************************************************************* 
** Function name  : win_fsize
** Arguments      : fp - 
** Return         : unsigned int 
** Date&Time      : 2012-09-05  10:05:23
** Description    : 
*********************************************************************************************/ 
unsigned int win_fsize(wxf_file_t fp)
{
	unsigned int size,temp;
	unsigned int pos = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	temp = ftell(fp); 
	fseek(fp, 0, SEEK_END);
	size = ftell(fp);
	fseek(fp, pos, SEEK_SET);
	return size - temp;
}
int win_fexist(const char *path)
{
	wxf_dir_t dir;
	wxf_file_t fp;

	fp = wxf_fopen(path,WXF_OM_READ);
	if (fp != WXF_ERR_FILE)
	{
		wxf_fclose(fp);
		return true;
	}
	dir = wxf_opendir(path);
	if (dir != WXF_ERR_DIR)
	{
		wxf_closedir(dir);
		return true;
	}
	return false;
}

#endif


#ifdef WIN32

//thread

//0 success; -1 error
int wxf_thread_create(wxf_hdl *phandle, ulong *pid, wxf_thdrt routine, void *param)
{
	unsigned int dwId;
	
	wxf_hdl h;
	
	h = (wxf_hdl)_beginthreadex(0, 0, routine, param, 0, &dwId);
	
	if(h == (wxf_hdl)-1)
		return -1;

	if(phandle)
	{
		*phandle = h;
		if (pid)
			*pid = dwId;

		return 0;
	}
	else
	{
		CloseHandle(h);

		return -1;
	}
}

//0 success; -1 error
int wxf_thread_detach(wxf_hdl phandle)
{
	CloseHandle(phandle);
	return 0;
}

//0 success; -1 error
int wxf_thread_join(wxf_hdl phandle, void **pretcode)
{
	if(WaitForSingleObject(phandle, INFINITE) == WAIT_OBJECT_0)
	{
		if(pretcode)
			GetExitCodeThread(phandle, (unsigned long*)pretcode);
		
		return 0;
	}

	return -1;
}

void wxf_thread_exit(unsigned int retval)
{
	_endthreadex(retval);
}


//mutex

//0 success; other error
int wxf_mutex_init(wxf_mutex *mutex)
{
	InitializeCriticalSection(mutex);
	return 0;
}

//0 success; other error
int wxf_mutex_lock(wxf_mutex *mutex)
{
	EnterCriticalSection(mutex);
	return 0;
}

//0 success; other error
int wxf_mutex_trylock(wxf_mutex *mutex)
{
	TryEnterCriticalSection(mutex);
	return 0;
}

//0 success; other error
int wxf_mutex_unlock(wxf_mutex *mutex)
{
	LeaveCriticalSection(mutex);
	return 0;
}

//0 success; other error
int wxf_mutex_destroy(wxf_mutex *mutex)
{
	DeleteCriticalSection(mutex);
	return 0;
}


//no name semaphore

//0 success; -1 error
int wxf_noname_sem_init(hnsem *sem, unsigned int value)
{
	*sem = CreateSemaphore(0, value, 0x7FFFFFFF, NULL);
	if(*sem == NULL)
		return -1;

	return 0;
}

//0 success; -1 error
int wxf_noname_sem_destroy(hnsem *sem)
{
	if(CloseHandle(*sem))
		return 0;
	return -1;
}

//0 success; -1 error
int wxf_noname_sem_wait(hnsem *sem)
{
	int ret = WaitForSingleObject(*sem, INFINITE);

	if(ret == WAIT_OBJECT_0)
		return 0;
	else
		return -1;
}

//0 success; -1 error
int wxf_noname_sem_post(hnsem *sem)
{
	if(ReleaseSemaphore(*sem, 1, 0))
		return 0;
	
	return -1;
}

//0 success; -1 error
int wxf_noname_sem_getvalue(hnsem *sem)
{
	/*
	long value=0;

	if(ReleaseSemaphore(*sem, 0, &value))
		return -1;
	else
		return value;
		*/
	return 0;
}

//dynamic linking loader

//0 success; -1 error
wxf_hdl wxf_load_library(const char *filename)
{
	wxf_hdl handle;

	if (filename == NULL)
	{
		return NULL;
	}

	handle=LoadLibrary(filename); 

	return handle;
}

//0 success; -1 error
void *wxf_get_addr(wxf_hdl handle, const char *module)
{
	void *ptr=NULL; 
    
    if (handle==NULL || module==NULL)
    { 
        return NULL; 
    }
    
    ptr=(void *)GetProcAddress((HINSTANCE)handle, module); 

	return ptr;
}

//0 success; -1 error
int wxf_free_library(wxf_hdl handle)
{
	if (handle == NULL)
	{
		return -1;
	}
	
    FreeLibrary((HINSTANCE)handle);

	return 0;
}

//NULLÎÞ´íÎó,·ñÔòÓÐ´íÎó
char *wxf_get_liberror()
{
	/*
	* ----- commented by qingch   4/8/2009 ------
  	return NULL;
	*/
	return strerror(errno);
}

//some useful functions

//0 success; other error
int wxf_sleep(unsigned int milliseconds)
{
	Sleep(milliseconds);
	return 0;
}

//0 success; -1 error
int wxf_getlocaltime(wxf_time *psystime)
{
	GetLocalTime(psystime);
	return 0;
}

//0 success; -1 error
int wxf_setlocaltime(const SYSTEMTIME *psystime)
{
	if(SetLocalTime(psystime))
		return 0;

	return -1;
}

//0 yes; -1 no
int wxf_pathfile_exist(const char *pathfile)
{
	if( _access(pathfile,0) != 0)
		return -1;
	
	return 0;
}

//0 yes; -1 no
int wxf_pathfile_exec(const char *pathfile)
{
	if( _access(pathfile,2) != 0)
		return -1;
	
	return 0;
}

//0 yes; -1 no
int wxf_pathfile_rw(const char *pathfile)
{
	if( _access(pathfile,6) != 0)
		return -1;

	return 0;
}

int wxf_get_file_size(const char *file_name)
{
	struct _stat file_desc;

	if (_stat(file_name, &file_desc) == 0)
	{
		return file_desc.st_size;
	}

	return -1;
}

int wxf_create_local_dir(char *szPath)  
{
	int			iIndex1=0,iIndex2=0;
	string		strFilePath;
	string		strFullFilePath;

	strFilePath = szPath;
	if (strFilePath.at(0) == '.')
	{
		iIndex2=strFilePath.find('\\', iIndex1+1);

		if(iIndex2==-1)
		{
			return FALSE;
		}

		iIndex1=iIndex2;
		strFullFilePath=".";
	}
	else 
	{
		if (wxf_pathfile_exist(strFilePath.c_str())==0)
		{
			return TRUE;
		}
	}

	while(iIndex1!=-1)
	{
		iIndex2=strFilePath.find('\\', iIndex1+1);

		if (iIndex2>0)
		{
			strFullFilePath += strFilePath.substr(iIndex1, iIndex2-iIndex1);

			if (wxf_pathfile_exist(strFullFilePath.c_str())!=0)
			{
				if (_mkdir((const char *)strFullFilePath.c_str())<0)
				{
					return FALSE;
				}
			}
		}
		else if(iIndex2==-1)
		{
			if((unsigned int)iIndex1!=strFilePath.size()-1)
			{
				strFullFilePath += strFilePath.substr(iIndex1, strFilePath.size()-1);
					
				if (wxf_pathfile_exist(strFullFilePath.c_str())!=0)
				{
					if (_mkdir((const char *)strFullFilePath.c_str())<0)
					{
						return FALSE;
					}
				}
			}
		}

		iIndex1=iIndex2;
	}

	return TRUE;
}
int wxf_msg_box(const char *fmt,...)
{
	// if the format string is NULL ,return 
	if (fmt == NULL)
	{
		return -1;
	}
		
	va_list argList;

	// Set va_list to the beginning of optional arguments
	va_start(argList, fmt);

	const char * ptr = fmt;
	char * str = NULL;

	//save the max len of the formatstring
	int    nMaxLen = 0;

	while(*ptr != '\0')
	{
		str = NULL;

		if(*ptr == '%')
		{
			switch(*(ptr+1))
			{
			case 's':
			case 'S':
				str = va_arg(argList,char*);

				if( NULL == str)
					nMaxLen ++;
				else
					nMaxLen += strlen(str);
				ptr++;
				break;

			case 'c':
			case 'C':
				va_arg(argList,char);
				nMaxLen +=2;
				ptr++;
				break;

			case 'd':
			case 'D':
				va_arg(argList, int);
				nMaxLen +=11;
				ptr++;
				break;

			case 'u':
			case 'U':
				va_arg(argList, unsigned int);
				nMaxLen +=10;
				ptr++;
				break;

			case 'l':
			case 'L':
				ptr++;
				if(*(ptr+1) == 'd')
				{
					va_arg(argList, long);
					nMaxLen +=11;
				}
				else if(*(ptr+1) == 'u')
				{
					va_arg(argList, unsigned long);
					nMaxLen +=10;
				}
				ptr++;
				break;
			case 'f':
			case 'F':
				va_arg(argList, double);
				nMaxLen += 31;
				ptr++;
				break;
			case 'x':
			case 'X':
				va_arg(argList, void*);
				nMaxLen += 2*sizeof(void*);
				ptr++;
				break;
			default:
				nMaxLen+=1;
			}
		} //  if(*ptr == '%')
		else
		{
			nMaxLen +=1;
		}
		// Increment pointer..
		ptr++;
	}

	// end va_list
	va_end(argList);


	nMaxLen += 255;       // ·ÀÖ¹ÌØÊâÇé¿ö³¤¶È¼ÆËã´íÎó£»
    char *buf = new char[nMaxLen]; 


	va_start(argList, fmt);  	
	vsprintf(buf, fmt, argList);	
	va_end(argList);
	
	MessageBox(NULL,buf,"",MB_OK);

	return nMaxLen;
}
#endif//OS_WINDOW


#ifdef WIN32


/*  È«¾Öº¯ÊýÊµÏÖ  */

/*************************************************************
 º¯ Êý Ãû£ºGetSysTime()
 ¹¦ÄÜ¸ÅÒª£º»ñµÃÏµÍ³µ±Ç°Ê±¼ä
 ·µ »Ø Öµ: void
 ²Î    Êý£ºSYSTIME& curTime
***************************************************************/
void GetSysTime(systime & curTime)
{
	//´æ·Å±¾µØÊ±¼ä
	time_t ltime=0;

	//tm ½á¹¹
	struct tm *today = NULL;

	//È¡µÃ±¾µØÊ±¼ä
	time(&ltime);

	//Ê±¼ä×ª»»ÎªtmÀàÐÍ
	today=localtime(&ltime); 
	
    //È¡Öµ
	curTime.wYear      = today->tm_year + 1900;  //tm ÖÐyear »ùÓÚ1900
	curTime.wMonth     = today->tm_mon +1 ;      //tm ÖÐmonth »ùÓÚ0
	curTime.wDay       = today->tm_mday;
	curTime.wHour      = today->tm_hour;
	curTime.wMinute    = today->tm_min ;
	curTime.wSecond    = today->tm_sec ;
	curTime.wDayOfWeek = today->tm_wday ;        //sunday is 0 ,monday is 1 ,and so on
    curTime.wDayOfYear = today->tm_yday + 1;     //tmÖÐ»ùÓÚ0¿ªÊ¼

	//²»Ö§³ÖÈ¥ºÁÃë,ÖÃ0
	curTime.wMilliseconds = 0;
}
/*************************************************************
 º¯ Êý Ãû£ºCreateSavePath()
 ¹¦ÄÜ¸ÅÒª: ´´½¨Â·¾¶
 ·µ »Ø Öµ: void
 ²Î    Êý£ºchar * szPath   Â·¾¶Ãû
***************************************************************/
void CreateSavePath(char * szPath)  
{
	wxf_create_local_dir(szPath);
}
/*************************************************************
 º¯ Êý Ãû£ºGetIniKey()
 ¹¦ÄÜ¸ÅÒª: »ñµÃÖ¸¶¨ÅäÖÃÎÄ¼þÖÐÖ¸¶¨¹Ø¼ü×ÖµÄÖµ
 ·µ »Ø Öµ: void
 ²Î    Êý£ºconst char * filename  ÅäÖÃÎÄ¼þÃû³Æ
           const * title     ÏîÄ¿Ãû³Æ
		   const * key       ¹Ø¼ü×ÖÃû³Æ
		   const * chResult  È¡µÃµÄ½á¹û
***************************************************************/
void GetIniKey(const char *filename, const char *title,
				  const char *key,char *chResult)
{
	if(chResult == NULL)
	{
		fprintf(stderr,"the last parameter is NULL in GetIniKey()");
		return ;
	}

	//ÎÄ¼þÖ¸Õë
	FILE * fp = NULL;

	//ÁÙÊ±±äÁ¿
	char tmpLine[1024]="";         // Ã¿ÐÐ×î¶à×Ö·ûÊý
	char every_line[1024]="";
	char tempKey[255]="";          // ±£´æÁÙÊ±¹Ø¼ü×Ö
	char tmpTitle[255]="";         // ±£´æÀúÊ·ÏîÄ¿Ãû³Æ
	char * pEveryLine = NULL;
   	char * pResult = NULL;

	//¶ÁÈ¡ÎÄ¼þ·µ»ØÖµ
	char * pReturn = NULL;

	int i=0,j=0,k=0,nLen = 0;

	//±êÖ¾Ò»¸öÏîÄ¿ÏÂµÄkeyÊÇ·ñÒÑ¾­É¨ÃèÍê
	int flag = 0;

	char * tmp=NULL;
	
	//´ò¿ªÎÄ¼þ
	if ((fp = fopen( filename, "r")) == NULL )
	{
		fprintf(stderr,"Open File %s Failed,Reason:%s \n",filename,strerror(errno));
		return;
	}

	//¶ÁÈ¡ÄÚÈÝ
	while (!feof(fp))
	{
		memset(tmpLine,0,1024);
		memset(every_line,0,1024);

		pReturn = fgets(every_line,1023,fp );    //¶ÁÈ¡Ò»ÐÐ

		if ( pReturn == NULL )                //ÎÄ¼þ½áÊø»ò·¢Éú´íÎó
		{  
			break; 
		}
		
		nLen = strlen(every_line);
        pEveryLine = every_line;
        j = 0;

		// È¥³ýÐÐÊ×¿Õ¸ñ(½«µÚÒ»¸ö²»Îª¿Õ¸ñ×Ö·ûÇ°µÄËùÓÐ¿Õ¸ñÈ¥³ý,)
		for(i =0; i<nLen; i++)
		{
			if(every_line[i] == 0x20)
			{
				j++;         // ¿Õ¸ñÊýÄ¿
			}
			else             // ³öÏÖ²»Îª¿Õ¸ñÊ±ÔòÍË³ö¸ÃÑ­»·
				break;
		}
        
		memcpy(tmpLine,pEveryLine+j,nLen-j);  // ¸´ÖÆ³ý¿Õ¸ñÍâµÄ×Ö·û
        nLen = nLen - j;                      // ÖØÐÂÉèÖÃ³¤¶È

		// ¹ýÂË×¢ÊÍÐÐ»ò¿ÕÐÐ
		if( ( tmpLine[0] == ';') ||                           // ';'ºÅ×¢ÊÍ 
		    ((tmpLine[0] == '/') && (tmpLine[1] == '/')) ||   // '//'×¢ÊÍ
		    ((tmpLine[0] == '/') && (tmpLine[1] == '*')) ||   // '/*'×¢ÊÍ
			((tmpLine[0] == '-') && (tmpLine[1] == '-')) ||   // '--'×¢ÊÍ
			((tmpLine[0] == '\r')&& (tmpLine[1] == '\n'))||   // windows ÏÂ»»ÐÐ·û(ÎÞ¿Õ¸ñµÄ¿ÕÐÐ)
			 (tmpLine[0] =='\n') )                            // linux/unixÏÂ»»ÐÐ·û (ÎÞ¿Õ¸ñµÄ¿ÕÐÐ)
		{
			continue;
		}	

        // È¥³ý»»ÐÐ·û
		if( (nLen >= 1) && (tmpLine[nLen-1] == '\n') )      // windows\linuxÏÂ»»ÐÐ·û×îºó¶¼Îª'\n'
			tmpLine[nLen-1] = 0;
		if( (nLen >= 2) && (tmpLine[nLen-2] == '\r') )      //  windowsÏÂ»»ÐÐ·ûÎªÔÚ'\n'Ö®Ç°»¹ÓÐ¸ö'\r'
			tmpLine[nLen-2] = 0;

		tmp = strchr(tmpLine, '=');
		
		//µÚÒ»´Î¶Áµ½ '=' Ó¦¸ÃÊÇ ÏîÄ¿Ãû³Æ
		if (( tmp != NULL )&&(flag == 1))
		{
			i= j = 0;
			memset(tempKey,0,255);

			//È¡³ö¹Ø¼ü×Ö
			while(tmpLine[j] != '=')
			{
				if(tmpLine[j] != 0x20)                        //È¥³ý¿Õ¸ñ
				{
					tempKey[i]=tmpLine[j];
					i++;

					if(i > 254)
						break;
				}
				j++;
			}
			
	    	//Èç¹û¹Ø¼ü×ÖÏàÍ¬ÔòÈ¡ÆäÖµ (È¥³ý½á¹ûÖÐµÄ¿Õ¸ñ)
			if(strcmp(tempKey,key) == 0)
			{
				nLen = strlen(tmp) - 1;
				tmp = tmp + 1;          // Ìø¹ý '='ºÅ
                pResult = chResult;

				while( nLen > 0)
				{
					if( (*tmp) != 0x20 )
					{
						*pResult = *tmp;
						pResult ++;
					}

                    tmp ++;
					nLen --;
				}

				fclose ( fp );        // ¹Ø±ÕÎÄ¼þ

				return ;
			}
		}
		else
		{
			//Èç¹ûflag=1,ÔòËµÃ÷Ç°Ò»¸ötitleÏÂµÄkeyÒÑ¾­¶ÁÍê
			if( flag == 1)
			{
				fprintf(stderr,"Section=[%s],Key=%s not exist in %s\n", \
					   title,key,filename);
				wxf_bzero(chResult,strlen(chResult));
				fclose(fp);
				return ;
			}
			memset(tmpTitle,0,255);

			// Éú³ÉÏîÄ¿Ãû³Æ
			strcpy(tmpTitle,"[");
			strcat(tmpTitle,title);
			strcat(tmpTitle,"]");
			
			// È·ÈÏ¶Áµ½µÄÐÅÏ¢ÊÇ·ñÓÐÏîÄ¿Ãû³Æ
			if( strstr(tmpLine,tmpTitle) != NULL )
			{
				flag = 1;   // ±êÊ¶ÕÒµ½title
			}
		}
	}

	fclose ( fp );

	fprintf(stderr,"Section=[%s],Key=%s not exist in %s\n",\
		    title,key,filename);
	wxf_bzero(chResult,strlen(chResult));
	return;
}

/*************************************************************
 º¯ Êý Ãû£ºEndThread()
 ¹¦ÄÜ¸ÅÒª: ½áÊøÏß³Ì
 ·µ »Ø Öµ: void
 ²Î    Êý£ºÎÞ
***************************************************************/
void EndThread()
{
	unsigned long code=0;
	ExitThread(code);
}

/*************************************************************
 º¯ Êý Ãû:   GetFormatPath
 ¹¦ÄÜ¸ÅÒª:   »ñµÃ¸ñÊ½»¯µÄÎÄ¼þÂ·¾¶£¬½«ËùÓÐµÄÐ±¸ÜÍ³Ò»Îª'/',×îºóÃ»ÓÐ'/'
			Ê±¼ÓÉÏ'/'
 ·µ »Ø Öµ:   std::string ¸ñÊ½»¯ºóµÄÂ·¾¶
 ²Î    Êý:   string sourcePath Ðè¸ñÊ½»¯µÄÂ·¾¶
**************************************************************/
string GetFormatPath(string sourcePath)
{
	string::size_type stPos(0);
	//
	while(string::npos != (stPos = sourcePath.find('\\',stPos))){
		sourcePath.replace(stPos,1,"/");
	}

	if((!sourcePath.empty()) && ((*(sourcePath.end()-1) != '/')))
	{
		sourcePath += '/';
  	}
	return sourcePath;
}

/*************************************************************
 º¯ Êý Ãû:   GetFileNameFromFullFileName
 ¹¦ÄÜ¸ÅÒª:   ´Ó´øÂ·¾¶µÄÎÄ¼þÃûÖÐ»ñÈ¡ÎÄ¼þÃû
 ·µ »Ø Öµ:   std::string	²»´øÂ·¾¶µÄÎÄ¼þÃû
 ²Î    Êý:   string sFullFileName	´øÂ·¾¶µÄÎÄ¼þÃû
**************************************************************/
string GetFileNameFromFullFileName(string sFullFileName)
{
	string::size_type n = sFullFileName.find_last_of('\\', sFullFileName.size());
	if (string::npos != n){
		sFullFileName.erase(0, n+1);
	}

	n = sFullFileName.find_last_of('/', sFullFileName.size());
	if (string::npos != n){
		sFullFileName.erase(0, n+1 );
	}
	return sFullFileName;
}

/*************************************************************
 º¯ Êý Ãû:   GetFilePathFromFullFileName
 ¹¦ÄÜ¸ÅÒª:   ´ÓÈ«ÎÄ¼þÃû£¨´øÂ·¾¶µÄ£©ÖÐ»ñÈ¡ÎÄ¼þÂ·¾¶£¬²¢Í³Ò»Îª'/'
 ·µ »Ø Öµ:   std::string	´¦ÀíºóµÄÎÄ¼þÂ·¾¶
 ²Î    Êý:   string sFullFileName	È«ÎÄ¼þÃû
**************************************************************/
string GetFilePathFromFullFileName(string sFullFileName)
{
	string sPath;
	string tFullFileName(sFullFileName);
	//¸ñÊ½»¯ ½«'\'Ìæ»»Îª'/'
	string::size_type stPos(0);
	while(string::npos != (stPos = tFullFileName.find('\\',stPos))){
		tFullFileName.replace(stPos,1,"/");
	}
	
	string::size_type n = tFullFileName.find_last_of('/', tFullFileName.size());
	if (string::npos != n){
		sPath.assign(sFullFileName,0,n+1);
	}

	return sPath;
}

bool PingDestination(const string pIp)
{
    char chPingFile[256];
    memset(chPingFile,0,256);
    sprintf(chPingFile,"ping(%s).txt",pIp.c_str());
    
    char chBuff[256] = "";
#ifdef OS_WINDOWS
    sprintf(chBuff,"ping  %s -n 3 -w 5000>%s",pIp.c_str(),chPingFile);
    system(chBuff);
#endif

#ifdef OS_LINUX
    FILE   *stream;
    FILE   *wstream;
    char   buf[8192];
    
#ifdef OS_SUNUNIX
    sprintf(chBuff,"ping -s -I 1 %s 1024 3",pIp.c_str());   
#elif defined OS_AIX
    sprintf(chBuff,"ping -c 3 -w 5 %s",pIp.c_str());  
#elif defined OS_HPUNIX
    sprintf(chBuff,"ping %s -n 3 -m 5",pIp.c_str());  	
#else
    sprintf(chBuff,"ping %s -c 3",pIp.c_str());  
#endif
    
    memset( buf, '\0', sizeof(buf) );//³õÊ¼»¯buf,ÒÔÃâºóÃæÐ´ÈçÂÒÂëµ½ÎÄ¼þÖÐ
    stream = popen( chBuff, "r" ); //½«¡°ls £­l¡±ÃüÁîµÄÊä³ö Í¨¹ý¹ÜµÀ¶ÁÈ¡£¨¡°r¡±²ÎÊý£©µ½FILE* stream
    if (stream==NULL)  
	{
		return false;
    }
	wstream = fopen(chPingFile, "w+"); //ÐÂ½¨Ò»¸ö¿ÉÐ´µÄÎÄ¼þ
    if (wstream==NULL)  
	{
		pclose(stream);
		return false;
    }	
    fread( buf, sizeof(char), sizeof(buf), stream); //½«¸Õ¸ÕFILE* streamµÄÊý¾ÝÁ÷¶ÁÈ¡µ½bufÖÐ
    fwrite( buf, 1, sizeof(buf), wstream );//½«bufÖÐµÄÊý¾ÝÐ´µ½FILE    *wstream¶ÔÓ¦µÄÁ÷ÖÐ£¬Ò²ÊÇÐ´µ½ÎÄ¼þÖÐ
    pclose( stream );  
    fclose( wstream );
#endif
    FILE   *pFile=NULL;
    pFile = fopen(chPingFile, "r");
    if (pFile == NULL)
    {
        return false;
    }
    
    char szTempBuff[256];
    int nNum=0;
    while (fgets(szTempBuff, 256, pFile) != NULL)
    {
        if (strstr(szTempBuff, "time=")!=NULL||
			strstr(szTempBuff, "time<")!=NULL||
			strstr(szTempBuff, "Ê±¼ä=")!=NULL||
			strstr(szTempBuff, "Ê±¼ä<")!=NULL )
        {
            nNum=nNum+1;
        }
    }
    fclose(pFile);
    pFile=NULL;
    remove(chPingFile);
    if(nNum>=2)
    {
        return true;
    }
    else
    {
        return false;
	}
}

WORD ReverseWordEndian(WORD pSourse)
{
    SWAP_16(pSourse);
    return pSourse;
}

int ReverseIntEndian(int pSourse)
{
    SWAP_32(pSourse);
    return pSourse;
}

float ReverseFloatEndian(float pSourse)
{
    SWAP_32(pSourse);
    return pSourse;
}

string FormatGatewayList(string pGatewayA, string pGatewayB)
{
    if(pGatewayA.size()>15) 
        pGatewayA.resize(15);
    if(pGatewayB.size()>15) 
        pGatewayB.resize(15);

    string strGatewayList(pGatewayA);
    strGatewayList += ",";
    strGatewayList += pGatewayB;

    return strGatewayList;
}

void GetGatewayFromList(string pGatewayList, string& pGatewayA, string& pGatewayB)
{
    pGatewayA.resize(0);
    pGatewayB.resize(0);
    string::size_type st_pos = pGatewayList.find_first_of(',');
    if (st_pos != string::npos)
    {
        pGatewayA.assign(pGatewayList,0,st_pos);
        pGatewayB.assign(pGatewayList,st_pos+1,pGatewayList.size()-st_pos-1);
        if(pGatewayA.size()>15) 
            pGatewayA.resize(15);
        if(pGatewayB.size()>15) 
            pGatewayB.resize(15);
    }
}

bool GetFileExFileName(const string& pSrcFileName,string& strExtName)
{
	bool bReturn(false);
	string::size_type n = pSrcFileName.find_last_of('.');
	if (string::npos != n)	{
		strExtName = pSrcFileName.substr(n,pSrcFileName.size());
		bReturn = true;
	}
	return bReturn;
}

#endif